name: Build & Deploy Pages (fable-collector)

on:
  workflow_dispatch:
    inputs:
      tz:
        description: "IANA timezone pour le filtre local (ex: Africa/Tunis)"
        default: "Africa/Tunis"
      local_hours_csv:
        description: "Heures locales autorisées (HH séparées par des virgules)"
        default: "00,06,12,18"
      force:
        description: "Ignorer le filtre d'heure locale et exécuter maintenant"
        type: boolean
        default: false
      window_hours:
        description: "Horizon de prévision en heures"
        default: "48"
      start_iso:
        description: "Optionnel: début ISO (YYYY-MM-DDTHH:MM) pour cibler la fenêtre"
        required: false
      only_sites:
        description: "Optionnel: restreindre à certains sites (CSV: noms/ids)"
        required: false
      reader_home:
        description: "JSON du port d’attache à utiliser par le reader"
        default: "gammarth-port.json"

  schedule:
    # ~00/06/12/18 Africa/Tunis (UTC+1)
    - cron: "0 23,5,11,17 * * *"
    # garde-fou horaire
    - cron: "0 * * * *"

  push:
    paths:
      - ".github/workflows/pages.yml"
      - "requirements.txt"
      - "main.py"
      - "reader.py"
      - "sites.yaml"

permissions:
  contents: read
  pages: write
  id-token: write

concurrency:
  group: "pages"
  cancel-in-progress: false

jobs:
  build:
    runs-on: ubuntu-latest
    outputs:
      should_run: ${{ steps.gate.outputs.should_run }}
      reason: ${{ steps.gate.outputs.reason }}
      tz_effective: ${{ steps.gate.outputs.tz_effective }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      # --- Gate heure locale / TZ ---
      - name: Gate on local hour (or force)
        id: gate
        env:
          DEFAULT_TZ: "Africa/Tunis"
          DEFAULT_LOCAL_HOURS: "00,06,12,18"
          INPUT_TZ: ${{ github.event_name == 'workflow_dispatch' && inputs.tz || '' }}
          INPUT_HOURS: ${{ github.event_name == 'workflow_dispatch' && inputs.local_hours_csv || '' }}
          INPUT_FORCE: ${{ github.event_name == 'workflow_dispatch' && (inputs.force && 'true' || 'false') || 'false' }}
        run: |
          TZ_INPUT="${INPUT_TZ:-$DEFAULT_TZ}"
          HOURS_CSV="${INPUT_HOURS:-$DEFAULT_LOCAL_HOURS}"
          FORCE="${INPUT_FORCE}"
          if [ "$FORCE" = "true" ]; then
            echo "should_run=true" >> $GITHUB_OUTPUT
            echo "reason=forced" >> $GITHUB_OUTPUT
          else
            hour=$(TZ=$TZ_INPUT date +%H)
            if echo "$HOURS_CSV" | tr ',' '\n' | grep -qx "$hour"; then
              echo "should_run=true" >> $GITHUB_OUTPUT
              echo "reason=matched_local_hour_$hour" >> $GITHUB_OUTPUT
            else
              echo "should_run=false" >> $GITHUB_OUTPUT
              echo "reason=skipped_local_hour_$hour" >> $GITHUB_OUTPUT
            fi
          fi
          echo "tz_effective=$TZ_INPUT" >> $GITHUB_OUTPUT

      - name: Show gate decision
        run: |
          echo "Gate: ${{ steps.gate.outputs.should_run }} (${{ steps.gate.outputs.reason }}) TZ=${{ steps.gate.outputs.tz_effective }}"

      - name: Setup Python
        if: steps.gate.outputs.should_run == 'true'
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Install deps
        if: steps.gate.outputs.should_run == 'true'
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt

      # --- Collecte JSON (robuste, sans &&/|| dans env) ---
      - name: Generate JSON (window, tz, targeting)
        if: steps.gate.outputs.should_run == 'true'
        env:
          FABLE_TZ: ${{ steps.gate.outputs.tz_effective }}
          INPUT_WINDOW_HOURS: ${{ github.event.inputs.window_hours }}
          INPUT_START_ISO:    ${{ github.event.inputs.start_iso }}
          INPUT_ONLY_SITES:   ${{ github.event.inputs.only_sites }}
        run: |
          set -e
          # Défauts si non-dispatch
          FABLE_WINDOW_HOURS="${INPUT_WINDOW_HOURS:-48}"
          FABLE_START_ISO="${INPUT_START_ISO:-}"
          FABLE_ONLY_SITES="${INPUT_ONLY_SITES:-}"

          echo "Using FABLE_TZ=$FABLE_TZ"
          echo "Using FABLE_WINDOW_HOURS=$FABLE_WINDOW_HOURS"
          [ -n "$FABLE_START_ISO" ]  && echo "Using FABLE_START_ISO=$FABLE_START_ISO"
          [ -n "$FABLE_ONLY_SITES" ] && echo "Using FABLE_ONLY_SITES=$FABLE_ONLY_SITES"

          export FABLE_TZ FABLE_WINDOW_HOURS FABLE_START_ISO FABLE_ONLY_SITES
          python main.py || (echo "Collector failed once, retrying in 6s..." && sleep 6 && python main.py)

      # --- Construire l'index des JSON (avant reader) ---
      - name: Build index.json (catalogue)
        if: steps.gate.outputs.should_run == 'true'
        shell: python
        run: |
          import json, pathlib, datetime
          pub = pathlib.Path("public")
          pub.mkdir(exist_ok=True)
          files = []
          for p in sorted(pub.glob("*.json")):
              if p.name in ("index.json", "windows.json"):
                  continue
              st = p.stat()
              mtime = datetime.datetime.fromtimestamp(st.st_mtime).astimezone().isoformat()
              files.append({"path": p.name, "size": st.st_size, "modified": mtime})
          idx = {"generated_at": datetime.datetime.now().astimezone().isoformat(), "files": files}
          (pub / "index.json").write_text(json.dumps(idx, ensure_ascii=False, indent=2), encoding="utf-8")
          print(f"Built index.json with {len(files)} item(s)")

      # --- Sanity check: index & existence des fichiers listés ---
      - name: "Sanity check: index & fichiers listés"
        if: steps.gate.outputs.should_run == 'true'
        shell: python
        env:
          READER_HOME: ${{ (github.event_name == 'workflow_dispatch' && inputs.reader_home) || 'gammarth-port.json' }}
        run: |
          import json, os, sys, pathlib
          pub = pathlib.Path('public')
          idx = pub / 'index.json'
          if not idx.exists():
              print('❌ public/index.json manquant'); sys.exit(1)
          try:
              data = json.loads(idx.read_text(encoding='utf-8'))
          except Exception as e:
              print('❌ index.json illisible:', e); sys.exit(1)
          files = data.get('files', [])
          if not files:
              print('❌ index.json ne référence aucun fichier JSON de spot'); sys.exit(1)
          missing = []
          for f in files:
              p = pub / f.get('path','')
              if not p.exists() or p.stat().st_size == 0:
                  missing.append(str(p))
          if missing:
              print('❌ Fichiers référencés manquants/vides:', missing); sys.exit(1)
          home = pub / os.environ.get('READER_HOME','gammarth-port.json')
          if not home.exists():
              print('❌ reader_home introuvable:', home); sys.exit(1)
          print('✅ Sanity pré-reader OK (', len(files), 'fichiers de spot)')

      # --- Sanity check: fraîcheur des spots (<= 10 min d'écart) ---
      - name: "Sanity check: fraîcheur des JSON de spots"
        if: steps.gate.outputs.should_run == 'true'
        shell: python
        run: |
          import json, pathlib, sys, datetime
          pub = pathlib.Path('public')
          idx = json.loads((pub/'index.json').read_text(encoding='utf-8'))
          files = [pub/f['path'] for f in idx.get('files',[])]
          mtimes = [(f.name, datetime.datetime.fromtimestamp(f.stat().st_mtime)) for f in files]
          mtimes.sort(key=lambda x: x[1])
          if not mtimes:
              print('❌ Aucun spot détecté'); sys.exit(1)
          oldest, newest = mtimes[0][1], mtimes[-1][1]
          skew = (newest - oldest).total_seconds()/60.0
          print('⏱️  Écart mtime min/max = %.1f min' % skew)
          if skew > 10:
              print('❌ Trop de décalage entre les JSON de spots (>10 min). Exemple:',
                    mtimes[0][0], oldest.isoformat(), 'vs', mtimes[-1][0], newest.isoformat())
              sys.exit(1)

      # --- (debug) aperçu d’un JSON ---
      - name: Show one site JSON (debug)
        if: steps.gate.outputs.should_run == 'true'
        run: |
          echo "==== public listing ===="
          ls -lah public || true
          echo "==== head of ${{ (github.event_name == 'workflow_dispatch' && inputs.reader_home) || 'gammarth-port.json' }} ===="
          head -c 1500 "public/${{ (github.event_name == 'workflow_dispatch' && inputs.reader_home) || 'gammarth-port.json' }}" || true
          echo

      # --- Reader FABLE -> produit public/windows.json ---
      - name: Run FABLE reader (detect Family GO)
        if: steps.gate.outputs.should_run == 'true'
        run: |
          set -e
          python reader.py \
            --from-dir public \
            --out public \
            --home "${{ (github.event_name == 'workflow_dispatch' && inputs.reader_home) || 'gammarth-port.json' }}"

      # --- Vérifier windows.json ---
      - name: "Sanity check: windows.json"
        if: steps.gate.outputs.should_run == 'true'
        shell: python
        run: |
          import json, pathlib, sys
          p = pathlib.Path('public/windows.json')
          if not p.exists():
              print('❌ public/windows.json manquant'); sys.exit(1)
          try:
              d = json.loads(p.read_text(encoding='utf-8'))
          except Exception as e:
              print('❌ windows.json illisible:', e); sys.exit(1)
          if 'windows' not in d:
              print('❌ windows.json ne contient pas la clé \"windows\"'); sys.exit(1)
          print('✅ windows.json OK —', len(d.get('windows', [])), 'destination(s)')

      # --- Générer windows.md (lisible humain) ---
      - name: "Create windows.md from windows.json"
        if: steps.gate.outputs.should_run == 'true'
        shell: python
        env:
          TZ_EFFECTIVE: ${{ steps.gate.outputs.tz_effective }}
        run: |
          import os, json, pathlib, datetime
          pub = pathlib.Path('public')
          d = json.loads((pub/'windows.json').read_text(encoding='utf-8'))
          ts = datetime.datetime.now().astimezone().strftime('%Y-%m-%d %H:%M %Z')
          lines = [
            '# FABLE — Fenêtres Family GO',
            '',
            f"Horodatage: {ts} ({os.getenv('TZ_EFFECTIVE','Africa/Tunis')})",
            ''
          ]
          wins = d.get('windows', [])
          if not wins:
            lines.append('- Aucune fenêtre Family GO détectée dans l’horizon analysé.')
          else:
            for w in wins:
              lines.append(f"## {w.get('dest_name','?')} ({w.get('dest_slug','?')})")
              for seg in w.get('windows', []):
                lines.append(f"- {seg['start']} → {seg['end']} ({seg['hours']} h)")
              lines.append('')
          (pub/'windows.md').write_text('\n'.join(lines)+'\n', encoding='utf-8')
          print('✅ public/windows.md généré')

      # --- Forcer la livraison statique & petit dashboard HTML ---
      - name: Add .nojekyll and dashboard index.html
        if: steps.gate.outputs.should_run == 'true'
        shell: python
        run: |
          import json, pathlib, html
          pub = pathlib.Path('public')
          (pub/'.nojekyll').write_text('', encoding='utf-8')
          idx = json.loads((pub/'index.json').read_text(encoding='utf-8'))
          rows = []
          for f in idx.get('files', []):
            rows.append(f"<tr><td>{html.escape(f['path'])}</td><td>{f.get('size','')}</td><td>{html.escape(f.get('modified',''))}</td></tr>")
          rows_html = "\n".join(rows)
          html_txt = f"""<!doctype html>
          <meta charset="utf-8">
          <title>fable-collector — dashboard</title>
          <h1>fable-collector</h1>
          <p><a href="index.json">index.json</a> · <a href="windows.json">windows.json</a> · <a href="windows.md">windows.md</a></p>
          <table border="1" cellpadding="6" cellspacing="0">
            <thead><tr><th>Spot JSON</th><th>Taille</th><th>Modifié</th></tr></thead>
            <tbody>
              {rows_html}
            </tbody>
          </table>
          """
          (pub/'index.html').write_text(html_txt, encoding='utf-8')

      # --- Résumé Markdown dans le Job Summary ---
      - name: "Job summary (windows)"
        if: steps.gate.outputs.should_run == 'true'
        shell: python
        run: |
          import os, json, pathlib
          p = pathlib.Path('public/windows.json')
          if not p.exists():
            raise SystemExit(0)
          d = json.loads(p.read_text(encoding='utf-8'))
          wins = d.get('windows', [])
          out = ["## FABLE — fenêtres Family GO", ""]
          if not wins:
            out.append("- Aucune fenêtre Family GO détectée.")
          else:
            for w in wins:
              out.append(f"- **{w.get('dest_name','?')}** ({w.get('dest_slug','?')}):")
              for seg in w.get('windows', []):
                out.append(f"  - {seg['start']} → {seg['end']} ({seg['hours']} h)")
          with open(os.environ["GITHUB_STEP_SUMMARY"], "a", encoding="utf-8") as fh:
            fh.write("\n".join(out) + "\n")

      # --- Vérification finale des sorties à publier ---
      - name: Final outputs check
        if: steps.gate.outputs.should_run == 'true'
        run: |
          set -e
          test -s public/index.json   || (echo 'index.json manquant ou vide' && exit 1)
          test -s public/windows.json || (echo 'windows.json manquant ou vide' && exit 1)
          test -s public/windows.md   || (echo 'windows.md manquant ou vide' && exit 1)
          test -s public/index.html   || (echo 'index.html manquant ou vide' && exit 1)
          echo '✅ Sorties prêtes à publier.'

      - name: List public artifacts
        if: steps.gate.outputs.should_run == 'true'
        run: |
          echo "==== public ===="
          ls -lah public || true
          echo "==============="

      # --- Publication Pages ---
      - name: Setup Pages
        if: steps.gate.outputs.should_run == 'true'
        uses: actions/configure-pages@v5

      - name: Upload artifact
        if: steps.gate.outputs.should_run == 'true'
        uses: actions/upload-pages-artifact@v3
        with:
          path: public

  deploy:
    needs: build
    if: needs.build.outputs.should_run == 'true'
    runs-on: ubuntu-latest
    environment:
      name: github-pages
      url: ${{ steps.deployment.outputs.page_url }}
    steps:
      - name: Deploy to GitHub Pages
        id: deployment
        uses: actions/deploy-pages@v4
