name: Build & Deploy Pages (fable-collector)

on:
  workflow_dispatch:
    inputs:
      tz:
        description: "IANA timezone pour le filtre local (ex: Africa/Tunis)"
        default: "Africa/Tunis"
      local_hours_csv:
        description: "Heures locales autorisées (HH séparées par des virgules)"
        default: "00,06,12,18"
      force:
        description: "Ignorer le filtre d'heure locale et exécuter maintenant"
        type: boolean
        default: false
      window_hours:
        description: "Horizon de prévision en heures"
        default: "48"
      start_iso:
        description: "Optionnel: début ISO (YYYY-MM-DDTHH:MM)"
        required: false
      only_sites:
        description: "Optionnel: restreindre à certains sites (CSV)"
        required: false
      reader_home:
        description: "JSON du port d’attache pour le reader"
        default: "gammarth-port.json"

  schedule:
    # 00:00/06:00/12:00/18:00 Africa/Tunis (UTC+1) + garde-fou horaire
    - cron: "0 * * * *"

  push:
    paths:
      - ".github/workflows/pages.yml"
      - "requirements.txt"
      - "main.py"
      - "reader.py"
      - "sites.yaml"
      - "rules.yaml"

permissions:
  contents: read
  pages: write
  id-token: write

concurrency:
  group: "pages"
  cancel-in-progress: true

jobs:
  build:
    runs-on: ubuntu-latest
    timeout-minutes: 15
    outputs:
      should_run: ${{ steps.gate.outputs.should_run }}
      reason: ${{ steps.gate.outputs.reason }}
      tz_effective: ${{ steps.gate.outputs.tz_effective }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      # --- Gate heure locale / TZ ---
      - name: Gate on local hour (or force)
        id: gate
        env:
          DEFAULT_TZ: "Africa/Tunis"
          DEFAULT_LOCAL_HOURS: "00,06,12,18"
          INPUT_TZ: ${{ github.event_name == 'workflow_dispatch' && inputs.tz || '' }}
          INPUT_HOURS: ${{ github.event_name == 'workflow_dispatch' && inputs.local_hours_csv || '' }}
          INPUT_FORCE: ${{ github.event_name == 'workflow_dispatch' && (inputs.force && 'true' || 'false') || 'false' }}
        run: |
          TZ_INPUT="${INPUT_TZ:-$DEFAULT_TZ}"
          HOURS_CSV="${INPUT_HOURS:-$DEFAULT_LOCAL_HOURS}"
          FORCE="${INPUT_FORCE}"

          if [ "$FORCE" = "true" ]; then
            echo "should_run=true" >> $GITHUB_OUTPUT
            echo "reason=forced" >> $GITHUB_OUTPUT
          else
            hour=$(TZ=$TZ_INPUT date +%H)
            if echo "$HOURS_CSV" | tr ',' '\n' | grep -qx "$hour"; then
              echo "should_run=true" >> $GITHUB_OUTPUT
              echo "reason=matched_local_hour_$hour" >> $GITHUB_OUTPUT
            else
              echo "should_run=false" >> $GITHUB_OUTPUT
              echo "reason=skipped_local_hour_$hour" >> $GITHUB_OUTPUT
            fi
          fi
          echo "tz_effective=$TZ_INPUT" >> $GITHUB_OUTPUT

      - name: Show gate decision
        run: |
          echo "Gate: ${{ steps.gate.outputs.should_run }} (${{ steps.gate.outputs.reason }}) TZ=${{ steps.gate.outputs.tz_effective }}"

      - name: Setup Python
        if: steps.gate.outputs.should_run == 'true'
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Install deps
        if: steps.gate.outputs.should_run == 'true'
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt

      - name: Check Astral availability
        if: steps.gate.outputs.should_run == 'true'
        shell: bash
        run: |
          python - <<'PY'
          import importlib, sys
          try:
              m = importlib.import_module('astral')
              from astral import Observer
              from astral.moon import moonrise, moonset, phase
              print("Astral version:", getattr(m, '__version__', 'unknown'))
              print("Observer OK:", Observer is not None)
              print("moonrise callable:", callable(moonrise))
          except Exception as e:
              print("❌ Astral import failed:", e)
              sys.exit(1)
          PY

      - name: Clean debug artifacts (optional)
        if: steps.gate.outputs.should_run == 'true'
        run: |
          rm -f public/_debug-* || true

      # --- Sanity check: sites.yaml ---
      - name: Sanity check — sites.yaml
        if: steps.gate.outputs.should_run == 'true'
        shell: python
        run: |
          import sys, pathlib
          import yaml
          p = pathlib.Path("sites.yaml")
          if not p.exists():
            print("❌ sites.yaml absent"); sys.exit(1)
          data = yaml.safe_load(p.read_text(encoding="utf-8"))
          if not isinstance(data, list) or not data:
            print("❌ sites.yaml doit être une LISTE non vide"); sys.exit(1)
          for i, s in enumerate(data, 1):
            if not isinstance(s, dict) or not all(k in s for k in ("name","lat","lon")):
              print(f"❌ entrée #{i} invalide"); sys.exit(1)
          print(f"✅ sites.yaml OK — {len(data)} site(s)")

      # --- Sanity check: rules.yaml (NOUVEAU) ---
      - name: Sanity check — rules.yaml
        if: steps.gate.outputs.should_run == 'true'
        shell: python
        run: |
          import sys, pathlib, yaml
          p = pathlib.Path("rules.yaml")
          if not p.exists():
            print("❌ rules.yaml absent"); sys.exit(1)
          data = yaml.safe_load(p.read_text(encoding="utf-8"))
          if not isinstance(data, dict) or "family" not in data:
            print("❌ rules.yaml doit contenir au moins la clé 'family'"); sys.exit(1)
          print("✅ rules.yaml OK")

      # --- Collecte JSON ---
      - name: Generate JSON (window, tz, targeting)
        if: steps.gate.outputs.should_run == 'true'
        env:
          FABLE_TZ: ${{ github.event_name == 'workflow_dispatch' && inputs.tz || steps.gate.outputs.tz_effective }}
          FABLE_WINDOW_HOURS: ${{ github.event_name == 'workflow_dispatch' && inputs.window_hours || '48' }}
          FABLE_START_ISO: ${{ github.event_name == 'workflow_dispatch' && inputs.start_iso || '' }}
          FABLE_ONLY_SITES: ${{ github.event_name == 'workflow_dispatch' && inputs.only_sites || '' }}
          FABLE_ASTRAL_FALLBACK: '1'
          LOG_LEVEL: 'WARNING'
          FABLE_DEBUG_DUMP: '0'
          FABLE_INCLUDE_EXTRAS: '0'
          FABLE_HTTP_RETRIES: '2'
          FABLE_HTTP_TIMEOUT_S: '15'
          FABLE_RULES_PATH: rules.yaml         # ← ajouté
        run: |
          set -e
          echo "Using FABLE_TZ=$FABLE_TZ"
          echo "Using FABLE_WINDOW_HOURS=$FABLE_WINDOW_HOURS"
          [ -n "$FABLE_START_ISO" ] && echo "Using FABLE_START_ISO=$FABLE_START_ISO"
          [ -n "$FABLE_ONLY_SITES" ] && echo "Using FABLE_ONLY_SITES=$FABLE_ONLY_SITES"
          python main.py || (echo "Collector failed once, retrying in 6s..." && sleep 6 && python main.py)

      # --- Construire un INVENTAIRE séparé (NE PAS écraser index.json de main.py) ---
      - name: Build catalog.json (listing fichiers)
        if: steps.gate.outputs.should_run == 'true'
        shell: python
        env:
          TZ_EFFECTIVE: ${{ steps.gate.outputs.tz_effective }}
        run: |
          import os, json, pathlib, datetime
          from zoneinfo import ZoneInfo
          tz = ZoneInfo(os.environ.get("TZ_EFFECTIVE","Africa/Tunis"))
          pub = pathlib.Path("public"); pub.mkdir(exist_ok=True)
          files = []
          for p in sorted(pub.glob("*.json")):
              if p.name in ("catalog.json",):
                  continue
              st = p.stat()
              mtime = datetime.datetime.fromtimestamp(st.st_mtime, tz).isoformat()
              files.append({"path": p.name, "size": st.st_size, "modified": mtime})
          (pub/"catalog.json").write_text(json.dumps({
              "generated_at": datetime.datetime.now(tz).isoformat(),
              "files": files
          }, ensure_ascii=False, indent=2), encoding="utf-8")
          print(f"Built catalog.json with {len(files)} item(s) in {tz.key})")

      # --- Sanity check — catalog & files ---
      - name: Sanity check — catalog & files
        if: steps.gate.outputs.should_run == 'true'
        shell: python
        env:
          READER_HOME: ${{ (github.event_name == 'workflow_dispatch' && inputs.reader_home) || 'gammarth-port.json' }}
        run: |
          import json, os, sys, pathlib
          pub = pathlib.Path('public')
          cat = pub / 'catalog.json'
          if not cat.exists():
              print('❌ public/catalog.json manquant'); sys.exit(1)
          data = json.loads(cat.read_text(encoding='utf-8'))
          files = data.get('files', [])
          if not files:
              print('❌ catalog.json ne référence aucun fichier'); sys.exit(1)
          missing = []
          for f in files:
              p = pub / f.get('path','')
              if not p.exists() or p.stat().st_size == 0:
                  missing.append(str(p))
          if missing:
              print('❌ Fichiers référencés manquants/vides:', missing); sys.exit(1)
          home = pub / os.environ.get('READER_HOME','gammarth-port.json')
          if not home.exists():
              print('❌ reader_home introuvable:', home); sys.exit(1)
          print('✅ Sanity OK (catalog.json + fichiers)')

      # --- Fraîcheur des JSON ---
      - name: Sanity check — fraîcheur des JSON
        if: steps.gate.outputs.should_run == 'true'
        shell: python
        run: |
          import json, pathlib, sys, datetime
          pub = pathlib.Path('public')
          files = [pub/f['path'] for f in json.loads((pub/'catalog.json').read_text(encoding='utf-8')).get('files',[])]
          if not files:
              print('❌ Aucun spot détecté'); sys.exit(1)
          mtimes = [(f.name, datetime.datetime.fromtimestamp(f.stat().st_mtime)) for f in files]
          mtimes.sort(key=lambda x: x[1])
          oldest, newest = mtimes[0][1], mtimes[-1][1]
          skew = (newest - oldest).total_seconds()/60.0
          print('⏱️  Écart mtime min/max = %.1f min' % skew)
          if skew > 10:
              print('❌ Trop de décalage entre les JSON de spots (>10 min).',
                    mtimes[0][0], oldest.isoformat(), 'vs', mtimes[-1][0], newest.isoformat())
              sys.exit(1)

      # --- (debug) aperçu d’un JSON ---
      - name: Show one site JSON (debug)
        if: steps.gate.outputs.should_run == 'true'
        run: |
          echo "==== public listing ===="
          ls -lah public || true
          echo "==== head of ${{ (github.event_name == 'workflow_dispatch' && inputs.reader_home) || 'gammarth-port.json' }} ===="
          head -c 1500 "public/${{ (github.event_name == 'workflow_dispatch' && inputs.reader_home) || 'gammarth-port.json' }}" || true
          echo

      # --- Reader FABLE -> public/windows.json ---
      - name: Run FABLE reader (detect Family GO)
        if: steps.gate.outputs.should_run == 'true'
        env:
          FABLE_RULES_PATH: rules.yaml         # ← ajouté
        run: |
          set -e
          python reader.py \
            --from-dir public \
            --out public \
            --home "${{ (github.event_name == 'workflow_dispatch' && inputs.reader_home) || 'gammarth-port.json' }}"

      # --- Vérifier windows.json ---
      - name: Sanity check — windows.json
        if: steps.gate.outputs.should_run == 'true'
        shell: python
        run: |
          import json, pathlib, sys
          p = pathlib.Path('public/windows.json')
          if not p.exists():
              print('❌ public/windows.json manquant'); sys.exit(1)
          d = json.loads(p.read_text(encoding='utf-8'))
          if 'windows' not in d:
              print('❌ windows.json ne contient pas la clé "windows"'); sys.exit(1)
          print('✅ windows.json OK —', len(d.get('windows', [])), 'destination(s)')

      # --- Générer windows.md lisible ---
      - name: Create windows.md from windows.json
        if: steps.gate.outputs.should_run == 'true'
        shell: python
        env:
          TZ_EFFECTIVE: ${{ steps.gate.outputs.tz_effective }}
        run: |
          import os, json, pathlib, datetime
          from zoneinfo import ZoneInfo
          pub = pathlib.Path('public')
          d = json.loads((pub/'windows.json').read_text(encoding='utf-8'))
          tz = ZoneInfo(os.environ.get('TZ_EFFECTIVE','Africa/Tunis'))
          ts = datetime.datetime.now(tz).strftime('%Y-%m-%d %H:%M %Z')
          lines = ['# FABLE — Fenêtres Family GO','',f'Horodatage: {ts} ({tz.key})','']
          wins = d.get('windows', [])
          if not wins:
            lines.append('- Aucune fenêtre Family GO détectée dans l’horizon analysé.')
          else:
            for w in wins:
              lines.append(f"## {w.get('dest_name','?')} ({w.get('dest_slug','?')})")
              for seg in w.get('windows', []):
                lines.append(f"- {seg['start']} → {seg['end']} ({seg['hours']} h)")
              lines.append('')
          (pub/'windows.md').write_text('\n'.join(lines)+'\n', encoding='utf-8')
          print('✅ public/windows.md généré')

      # --- Tableau de bord statique + .nojekyll ---
      - name: Add .nojekyll (keep static index.html)
        if: steps.gate.outputs.should_run == 'true'
        run: |
          mkdir -p public
          : > public/.nojekyll

          cat = json.loads((pub/'catalog.json').read_text(encoding='utf-8'))
          rows = []
          for f in cat.get('files', []):
            path = html.escape(f['path'])
            rows.append(
              f"<tr><td><a href='{path}'>{path}</a></td>"
              f"<td>{f.get('size','')}</td>"
              f"<td>{html.escape(f.get('modified',''))}</td></tr>"
            )
          html_txt = f"""<!doctype html>
          <meta charset="utf-8">
          <title>fable-collector — dashboard ({tz.key})</title>
          <h1>fable-collector</h1>
          <p>
            <a href="index.json">index.json (spots par main.py)</a> ·
            <a href="catalog.json">catalog.json (listing fichiers)</a> ·
            <a href="windows.json">windows.json</a> ·
            <a href="windows.md">windows.md</a>
          </p>
          <p><em>Horaires affichés en {tz.key}.</em></p>
          <table border="1" cellpadding="6" cellspacing="0">
            <thead><tr><th>Spot JSON</th><th>Taille</th><th>Modifié ({tz.key})</th></tr></thead>
            <tbody>
              {''.join(rows)}
            </tbody>
          </table>
          """
          (pub/'index.html').write_text(html_txt, encoding='utf-8')
          print('✅ public/index.html généré')

      # --- Résumé ---
      - name: Job summary (windows)
        if: steps.gate.outputs.should_run == 'true'
        shell: python
        run: |
          import os, json, pathlib
          p = pathlib.Path('public/windows.json')
          if not p.exists():
              raise SystemExit(0)
          d = json.loads(p.read_text(encoding='utf-8'))
          wins = d.get('windows', [])
          out = ["## FABLE — fenêtres Family GO", ""]
          if not wins:
              out.append("- Aucune fenêtre Family GO détectée.")
          else:
              for w in wins:
                  out.append(f"- **{w.get('dest_name','?')}** ({w.get('dest_slug','?')}):")
                  for seg in w.get('windows', []):
                      out.append(f"  - {seg['start']} → {seg['end']} ({seg['hours']} h)")
          with open(os.environ["GITHUB_STEP_SUMMARY"], "a", encoding="utf-8") as fh:
              fh.write("\n".join(out) + "\n")

      # --- Vérification finale ---
      - name: Final outputs check
        if: steps.gate.outputs.should_run == 'true'
        run: |
          set -e
          test -s public/index.json   || (echo 'index.json manquant ou vide' && exit 1)
          test -s public/catalog.json || (echo 'catalog.json manquant ou vide' && exit 1)
          test -s public/windows.json || (echo 'windows.json manquant ou vide' && exit 1)
          test -s public/windows.md   || (echo 'windows.md manquant ou vide' && exit 1)
          test -s public/index.html   || (echo 'index.html manquant ou vide' && exit 1)
          echo '✅ Sorties prêtes à publier.'

      - name: List public artifacts
        if: steps.gate.outputs.should_run == 'true'
        run: |
          echo "==== public ===="
          ls -lah public || true
          echo "==============="

      # --- Publication Pages ---
      - name: Setup Pages
        if: steps.gate.outputs.should_run == 'true'
        uses: actions/configure-pages@v5

      - name: Upload artifact
        if: steps.gate.outputs.should_run == 'true'
        uses: actions/upload-pages-artifact@v3
        with:
          path: public

  deploy:
    needs: build
    if: needs.build.outputs.should_run == 'true'
    runs-on: ubuntu-latest
    environment:
      name: github-pages
      url: ${{ steps.deployment.outputs.page_url }}
    steps:
      - name: Deploy to GitHub Pages
        id: deployment
        uses: actions/deploy-pages@v4
